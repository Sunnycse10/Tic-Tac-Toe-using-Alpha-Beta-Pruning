import java.util.ArrayList;

public class MiniMax {
	private int bestMove=0;
	int count;
	int maximum=Integer.MIN_VALUE;
	int minimum=Integer.MAX_VALUE;
	
	//This Method will return the index of the position in the GRID
	public int getBestMove(Placement[][] placements, int player)
	{
		count=0;
		bestMove=0;
		MiniMax(placements, player,true, 0, maximum, minimum); //Calling Minimax method to calculate best Move which is the best
		System.out.println(count);//position
		return bestMove;
		
	}
	
	//This is a recursive and backtracking algorithm
	//player is either 0 or 1, in this case, player is 1, that means computer's move/Maximizer's move
	//depth is usual depth of a tree, it will increase after every step, the lower the depth, the better
	//it is for Maximizer
	private int MiniMax(Placement[][] placements, int player, boolean Maximizer, int depth, int alpha, int beta) {
		// TODO Auto-generated method stub
		count++;
		int score=0;
		int winner= Checker.getWinType(placements);//Checker.getWinType will return if its win for "0" player or 
		//"1" player
		//Comparing if its either 0 or 1 cause if its not win state/ Match state, this Checker.getWinType
		//will return -1. So if its greater or equal 0, that means, its goal state
		if(winner>=0 || getPlacementCount(placements)==Main.SIZE)
		{
			return getScore(placements, player, depth);// this method will return grid size - depth for every goal state
			//for maximizer, for minimizer, it will return depth-grid size
		}
		ArrayList<Integer> scores= new ArrayList<Integer>();// this arraylist will store all the values 
		//generated for every possible combinations
		int[] freeindexes= getFreeIndexes(placements);//this method will return an array of free indexes in the grid
		for(int i=0;i<freeindexes.length;i++)
		{
			int x=freeindexes[i]%Main.ROWS;
			int y=freeindexes[i]/Main.ROWS;
			/*if(!Maximizer)
			{
				depth++;//if not maximizer, the depth will be increased by one
			}*/
			int playerType= Maximizer? player : player+1; //maximizer and minimizer will be 0 or 1 , vice versa
			placements[x][y]= new Placement(playerType);// allocating new position in the grid
			score=MiniMax(placements, player, !Maximizer, depth+1,alpha,beta);// resursing it till we find goal state
			scores.add(score);// adding the values generated by every possible combinations for maximizer and minimizer
			placements[x][y]=null;// backtracking step, undoing the position.
			if(Maximizer)
			{
				int max= Math.max(maximum, score);
				alpha=Math.max(alpha, max);
				if(alpha>=beta)
					return max;
			}
			if(!Maximizer)
			{
				int min= Math.min(minimum, score);
				beta=Math.min(beta, min);
				if(alpha>beta)
					return min;
			}
			
		}
		int scoreIndex= 0;
		if(Maximizer)
		{
			scoreIndex=getMax(scores);//this method will return index of the maximum value in the arraylist
		}
		else
		{
			scoreIndex=getMin(scores);// this method will return index of the minimum value in the arraylist
		}
		bestMove=freeindexes[scoreIndex];//setting the index position of best value at best move position
		//which will be used to find row and column position for AI. 
		return scores.get(scoreIndex);// returning maximum value or minimum value after every recusrive move
		//at value of score
	}
	
	//this method will return index of minimum value for minimizer move
	private int getMin(ArrayList<Integer> scores) {
		// TODO Auto-generated method stub
		int index=0;
		int min=9999999;
		for(int i=0;i<scores.size();i++)
		{
			if(scores.get(i)<=min)
			{
				min=scores.get(i);
				index=i;
			}
		}
		return index;
	}

	// this method will return index of maximum value for maximizer move
	private int getMax(ArrayList<Integer> scores) {
		// TODO Auto-generated method stub
		int index=0;
		int max=-9999999;
		for(int i=0;i<scores.size();i++)
		{
			if(scores.get(i)>=max)
			{
				max=scores.get(i);
				index=i;
			}
		}
		return index;
	}

	//this method will return goal state- depth for maximizer and depth-goal state for minimizer
	private int getScore(Placement[][] placements, int player, int depth) {
		// TODO Auto-generated method stub
		ArrayList<Placement> match= Checker.checkWin(placements);
		if(match==null)
			return 0;
		if(match.get(0).getType()==player)
			return Main.SIZE-depth;
		
		else
			return depth-Main.SIZE;
	}
	//this method will return an array of free indexes
	private int[] getFreeIndexes(Placement[][] placements)
	{
		int[] freeIndexes= new int[Main.SIZE-getPlacementCount(placements)];
		int index=0;
		for(int i=0;i< placements.length;i++)
		{
			for(int j=0;j<placements[0].length;j++)
			{
				if(placements[i][j]==null)
				{
					freeIndexes[index]=j*Main.ROWS+i;
					index++;
				}
			}
		}
		return freeIndexes;
	}
	//this method will return count of occupied position in the grid
	private int getPlacementCount(Placement[][] placements) {
		// TODO Auto-generated method stub
		int count=0;
		for(int i=0;i<placements.length;i++)
		{
			for(int j=0;j<placements[0].length;j++)
			{
				if(placements[i][j]!=null)
					count++;
			}
		}

		return count;
	}

}
